# PA3 语法分析器作业说明

## 一、任务要求

### 1.1 作业目标

本次作业要求你完成一个Cool语言的语法分析器（Parser）。你将使用**Bison**工具来编写语法规则，将词法分析器（Lexer）输出的token流转换为抽象语法树（AST）。

### 1.2 主要任务

1. **完成 `cool.y` 文件**：这是你唯一需要修改的文件。你需要：
   - 定义语法规则（grammar rules）
   - 为每个语法规则编写语义动作（semantic actions），构建AST节点
   - 处理运算符优先级和结合性
   - 实现错误恢复机制

2. **测试和调试**：
   - 确保 `good.cl` 中的所有合法语法都能正确解析
   - 确保 `bad.cl` 中的语法错误能被正确检测和报告
   - 添加自己的测试用例

3. **编写报告**：在README文件中说明你的设计决策、代码正确性证明和测试用例的充分性

## 二、文件说明

### 2.1 必须修改的文件

- **`cool.y`**：这是你唯一需要修改的文件。包含语法规则定义和语义动作。

### 2.2 可以修改的文件

- **`README`**：用于写你的作业报告，包括设计说明、正确性证明和测试说明。

### 2.3 禁止修改的文件

以下文件**绝对不能修改**，否则会导致编译失败或评分错误：

- **`Makefile`**：编译配置文件
- **`parser-phase.cc`**：解析器驱动程序
- **`tokens-lex.cc`**：token流读取器（从lexer输出读取token）
- **`dumptype.cc`**：AST输出格式化程序
- **`handle_flags.cc`**：命令行参数处理
- **`cool-tree.aps`**：AST节点定义规范
- **`cool-tree.handcode.h`**：AST节点的手写扩展
- **`tree.cc`**、**`cool-tree.cc`**、**`stringtab.cc`**、**`utilities.cc`**：基础设施代码

### 2.4 自动生成的文件

以下文件由Bison自动生成，**不要手动编辑**：

- **`cool-parse.cc`**：从`cool.y`生成的C++解析器代码
- **`cool-parse.h`**：从`cool.y`生成的头文件
- **`cool.tab.h`**：Bison生成的token定义
- **`cool.output`**：Bison生成的解析器状态机描述（用于调试）

## 三、环境设置和使用方法

### 3.1 链接必要的文件

在开始工作前，需要链接一些必要的文件：

```bash
# 进入作业目录
cd /usr/class/assignments/PA3

# 链接官方lexer（词法分析器）
ln -s /usr/class/bin/lexer .

# 如果需要，链接其他工具
ln -s /usr/class/bin/semant .
ln -s /usr/class/bin/cgen .
```

**重要提示**：
- 每次执行 `make clean` 后，`lexer` 等符号链接会被删除，需要重新链接
- 建议在Makefile中添加链接命令，或创建一个setup脚本

### 3.2 编译

#### 3.2.1 编译过程详解

执行 `make parser` 时，Makefile会按以下步骤工作：

1. **生成解析器代码**：如果`cool.y`被修改或`cool-parse.cc`不存在，Makefile会执行：
   ```bash
   bison -d -v -y -b cool --debug -p cool_yy cool.y
   mv -f cool.tab.c cool-parse.cc
   ```
   这会：
   - 读取`cool.y`文件
   - 生成`cool-parse.cc`（C++解析器代码）
   - 生成`cool-parse.h`（头文件）
   - 生成`cool.tab.h`（token定义）
   - 生成`cool.output`（状态机描述，用于调试）

2. **编译所有源文件**：将`.cc`文件编译成`.o`目标文件
   - `parser-phase.cc` → `parser-phase.o`
   - `cool-parse.cc` → `cool-parse.o`
   - `cool-tree.cc` → `cool-tree.o`
   - 等等...

3. **链接生成可执行文件**：将所有`.o`文件链接成`parser`可执行文件

#### 3.2.2 编译命令

```bash
# 编译parser
make parser

# 如果遇到链接错误，先清理再编译
make clean
make parser

# 只重新生成Bison文件（不编译）
bison -d -v -y -b cool --debug -p cool_yy cool.y
mv -f cool.tab.c cool-parse.cc
```

#### 3.2.3 编译错误排查

如果编译失败，检查以下几点：

1. **Bison语法错误**：
   - 检查`cool.y`中的语法规则是否正确
   - 检查`%token`、`%type`声明是否正确
   - 检查语义动作中的C++代码语法

2. **C++编译错误**：
   - 检查头文件包含是否正确
   - 检查类型声明是否匹配
   - 检查AST节点构造函数调用是否正确

3. **链接错误**：
   - 确保在`cool.y`的第二个`%%`之后定义了所有必要的全局变量
   - 检查是否有未定义的函数或变量

### 3.3 测试

```bash
# 方法1：使用myparser脚本（推荐）
./myparser good.cl
./myparser bad.cl

# 方法2：手动运行lexer和parser
./lexer good.cl | ./parser

# 方法3：使用make目标
make dotest
```

### 3.4 运行完整编译器

```bash
# 使用完整的Cool编译器（包含lexer、parser、semant、cgen）
mycoolc test.cl

# 或者手动链接你的lexer（如果完成了PA2）
# 替换lexer符号链接指向你的lexer
```

## 四、调试方法

### 4.1 查看Token流

首先确认lexer输出的token是否正确：

```bash
# 查看lexer输出的token流
./lexer good.cl

# 或者使用官方lexer
/usr/class/bin/lexer good.cl
```

输出格式为：
```
#name "filename"
#行号 TOKEN名称 [值]
#行号 TOKEN名称 [值]
...
```

### 4.2 对比官方Parser输出

使用官方parser来对比你的输出：

```bash
# 使用官方parser解析
./lexer good.cl | /usr/class/bin/parser > official_output.txt

# 使用你的parser解析
./lexer good.cl | ./parser > my_output.txt

# 对比输出
diff official_output.txt my_output.txt
```

### 4.3 查看Bison生成的解析器状态

Bison生成的 `cool.output` 文件包含了解析器状态机的详细信息：

```bash
# 查看状态机描述
cat cool.output | less

# 搜索特定状态
grep "State 0" cool.output
```

### 4.4 常见错误和调试技巧

1. **语法错误（syntax error）**：
   - 检查token值是否与`cool-parse.h`中的定义匹配
   - 检查语法规则是否正确
   - 查看错误信息中的token名称，确认是哪个token导致错误

2. **链接错误**：
   - 确保所有必要的全局变量都已定义（如`ast_root`、`self_sym`、`omerrs`等）
   - 检查函数声明是否正确

3. **编译错误**：
   - 检查`cool.y`中的C++代码语法
   - 确保所有使用的类型都已包含相应的头文件

4. **运行时错误**：
   - 使用gdb调试：
     ```bash
     gdb ./parser
     run
     # 输入token流或从文件读取
     ```

### 4.5 使用官方工具对比（作为考核对象哦！）
只有行号不对的话，也算80%的分数。（弄对行号比较难搞）
文件的目录根据自己的系统合理的设置即可。
```bash
# 对比lexer输出
diff <(./lexer good.cl) <(/usr/class/bin/lexer good.cl)

# 对比parser输出
diff <(./lexer good.cl | ./parser) <(/usr/class/bin/lexer good.cl | /usr/class/bin/parser)

# 对比完整编译器输出
diff <(mycoolc good.cl 2>&1) <(/usr/class/bin/coolc good.cl 2>&1)
```

## 五、cool.y文件结构详解

### 5.1 cool.y文件的完整结构

`cool.y`文件由以下几个部分组成：

```bison
%{
/* 第一部分：C/C++代码块 */
/* 包含头文件、变量声明、宏定义等 */
#include "cool-tree.h"
extern int curr_lineno;
%}

/* 第二部分：Bison声明部分 */
/* 包括%union、%token、%type、优先级声明等 */

%union {
  /* 定义语义值类型 */
}

%token /* token声明 */

%type /* 非终结符类型声明 */

%left/%right/%nonassoc /* 运算符优先级 */

%start /* 起始符号 */

%%
/* 第三部分：语法规则部分 */
/* 定义所有语法规则和语义动作 */

%%
/* 第四部分：C/C++代码块 */
/* 定义全局变量、函数实现等 */
int curr_lineno = 1;
void yyerror(char *s) { ... }
```

### 5.2 各部分详细说明

#### 5.2.1 第一部分：C/C++代码块（第一个`%{`和`%}`之间）

这部分代码会被直接复制到生成的`cool-parse.cc`文件的开头。通常包括：

- **头文件包含**：
  ```c++
  #include "cool-tree.h"      // AST节点定义
  #include "stringtab.h"      // 字符串表
  #include "utilities.h"       // 工具函数
  ```

- **外部变量声明**：
  ```c++
  extern char *curr_filename;  // 当前文件名
  extern int curr_lineno;      // 当前行号
  ```

- **宏定义**：
  ```c++
  #define YYLTYPE int          // 位置信息类型
  #define SET_NODELOC(Current) node_lineno = Current;
  ```

- **函数声明**：
  ```c++
  void yyerror(char *s);       // 错误处理函数
  extern int cool_yylex();     // 词法分析器入口
  ```

#### 5.2.2 第二部分：Bison声明部分

- **%union**：定义所有可能的语义值类型
- **%token**：声明所有token及其类型
- **%type**：声明非终结符的类型
- **%left/%right/%nonassoc**：定义运算符优先级和结合性
- **%start**：指定起始符号（默认为第一个规则）

#### 5.2.3 第三部分：语法规则部分（两个`%%`之间）

定义所有语法规则，每个规则包含：
- 产生式（左部 : 右部）
- 语义动作（用`{}`包围的C++代码）

#### 5.2.4 第四部分：C/C++代码块（第二个`%%`之后）

这部分代码会被直接复制到生成的`cool-parse.cc`文件的末尾。通常包括：

- **全局变量定义**：
  ```c++
  int curr_lineno = 1;
  Symbol self_sym = idtable.add_string("self");
  ```

- **函数实现**：
  ```c++
  void yyerror(char *s) {
    // 错误处理实现
  }
  ```

## 六、Bison语法规则简介

### 6.1 基本结构

Bison文件的基本结构：

```bison
%{
// C/C++代码，包括头文件、变量声明等
#include "cool-tree.h"
extern int curr_lineno;
%}

// Token声明
%token CLASS TYPEID OBJECTID

// 语义值类型定义
%union {
    Symbol symbol;
    Expression expression;
    // ...
}

// 非终结符类型声明
%type <expression> expr
%type <symbol> identifier

// 运算符优先级
%left '+' '-'
%right '='
%nonassoc '<' '>'

%%
// 语法规则
program : class_list { /* 语义动作 */ }
        ;

class_list : class { $$ = single_Classes($1); }
          | class_list class { $$ = append_Classes($1, single_Classes($2)); }
          ;

%%
// C/C++代码，包括函数定义
```

### 6.2 Token声明

#### 6.2.1 Token声明格式

```bison
// 基本token（无值）
%token CLASS IF THEN ELSE

// 带值的token（需要指定类型）
%token <symbol> TYPEID OBJECTID INT_CONST STR_CONST
%token <boolean> BOOL_CONST

// 字符token（单引号，用于运算符）
%token '+' '-' '*' '/' '(' ')' '{' '}' ';' ',' ':' '@' '.' '~' '<' '='
```

#### 6.2.2 Token值的重要性

**重要**：token的数值必须与`cool.tab.h`（由Bison生成）和词法分析器输出的token值完全一致！

在`cool.y`中，token的数值是显式指定的：
```bison
%token CLASS 258 ELSE 259 FI 260 IF 261 IN 262
%token INHERITS 263 LET 264 LOOP 265 POOL 266 THEN 267 WHILE 268
%token CASE 269 ESAC 270 OF 271 DARROW 272 NEW 273 ISVOID 274
%token <symbol>  STR_CONST 275 INT_CONST 276
%token <boolean> BOOL_CONST 277
%token <symbol> TYPEID 278 OBJECTID 279
%token ASSIGN 280 NOT 281 LE 282 ERROR 283
```

这些数值必须与词法分析器（lexer）输出的token值匹配。如果token值不匹配，解析器将无法正确识别token，导致语法错误。

#### 6.2.3 如何查看Token值

1. **查看Bison生成的定义**：
   ```bash
   grep "CLASS\|TYPEID\|OBJECTID" cool.tab.h
   ```

2. **查看lexer输出的token**：
   ```bash
   ./lexer good.cl | head -20
   ```
   输出格式：`#行号 TOKEN名称 [值]`

3. **对比官方定义**：
   ```bash
   grep "CLASS\|TYPEID" /usr/class/include/PA3/cool-parse.h
   ```

### 6.3 语法规则

#### 6.3.1 语法规则的基本格式

```bison
非终结符 : 产生式1 { 语义动作1 }
         | 产生式2 { 语义动作2 }
         | 产生式3 { 语义动作3 }
         ;
```

**说明**：
- 左部是**非终结符**（必须用`%type`声明类型）
- 右部是**产生式**，由终结符（token）和非终结符组成
- 每个产生式后面可以跟**语义动作**（用`{}`包围的C++代码）
- 多个产生式用`|`分隔
- 规则以`;`结束

#### 6.3.2 语法规则示例

```bison
expr : expr '+' expr { $$ = plus($1, $3); }
     | expr '-' expr { $$ = sub($1, $3); }
     | INT_CONST     { $$ = int_const($1); }
     | '(' expr ')'  { $$ = $2; }
     ;
```

**解释**：
- `expr '+' expr`：表示表达式 + 表达式
- `$$ = plus($1, $3)`：创建加法AST节点，`$1`是左操作数，`$3`是右操作数
- `INT_CONST`：整数常量token
- `'(' expr ')'`：括号表达式，直接返回内部表达式（`$2`）

#### 6.3.3 递归规则

很多语法规则是递归的，用于处理列表：

```bison
class_list : class
             { $$ = single_Classes($1); }
           | class_list class
             { $$ = append_Classes($1, single_Classes($2)); }
           ;
```

**解释**：
- 第一个产生式：单个类 → 创建包含一个类的列表
- 第二个产生式：类列表 + 类 → 将新类追加到列表末尾
- 这样可以通过递归匹配多个类定义

### 6.4 语义动作中的变量

#### 6.4.1 变量说明

- **`$$`**：当前规则的返回值（左值），类型由`%type`声明决定
- **`$1, $2, $3, ...`**：产生式右部第1、2、3...个符号的语义值
- **`@$`**：当前规则的位置信息（行号）
- **`@1, @2, ...`**：产生式右部各符号的位置信息（行号）

#### 6.4.2 示例详解

```bison
class : CLASS TYPEID '{' feature_list '}' ';'
      { 
          // $1 = CLASS token（通常不使用，因为关键字没有语义值）
          // $2 = TYPEID的值（Symbol类型，类名）
          // $3 = '{' token（通常不使用）
          // $4 = feature_list的值（Features类型，方法/属性列表）
          // $5 = '}' token（通常不使用）
          // $6 = ';' token（通常不使用）
          // @1 = CLASS所在行号
          // @2 = TYPEID所在行号
          // @4 = feature_list的位置信息
          
          @$ = @1;  // 设置当前规则的行号为第一个token的行号
          $$ = class_($2,                          // 类名
                      idtable.add_string("Object"), // 父类名（默认Object）
                      $4,                           // 特征列表
                      stringtable.add_string(curr_filename)); // 文件名
      }
      ;
```

#### 6.4.3 AST节点构造函数

每个AST节点类型都有对应的构造函数，在`cool-tree.h`中定义。常用构造函数：

- **类相关**：
  - `class_(name, parent, features, filename)`：创建类节点
  - `method(name, formals, return_type, expr)`：创建方法节点
  - `attr(name, type_decl, init)`：创建属性节点

- **表达式相关**：
  - `plus(e1, e2)`：加法表达式
  - `sub(e1, e2)`：减法表达式
  - `assign(name, expr)`：赋值表达式
  - `cond(pred, then_exp, else_exp)`：条件表达式
  - `loop(pred, body)`：循环表达式
  - `let(var, type_decl, init, body)`：let表达式
  - `dispatch(expr, name, actuals)`：方法调用
  - `static_dispatch(expr, type_name, name, actuals)`：静态方法调用

- **列表相关**：
  - `single_Classes(class_)`：创建包含一个类的列表
  - `append_Classes(list, single_Classes(class_))`：追加类到列表
  - `nil_Features()`：空特征列表
  - `single_Features(feature)`：创建包含一个特征的列表
  - `append_Features(list, single_Features(feature))`：追加特征到列表

**如何查找构造函数**：
```bash
# 查看cool-tree.h中的构造函数定义
grep "class_\|method\|attr\|plus\|sub" /usr/class/include/PA3/cool-tree.h
```

### 6.5 运算符优先级和结合性

#### 6.5.1 优先级声明

```bison
// 优先级从低到高（越靠后优先级越高）
%nonassoc IN          // 最低优先级，无结合
%right ASSIGN         // 右结合（a = b = c 解析为 a = (b = c)）
%right NOT            // 右结合
%nonassoc LE '<' '='  // 无结合（不能连续出现，如 a < b < c 是语法错误）
%left '+' '-'         // 左结合，同一优先级（a + b - c 解析为 (a + b) - c）
%left '*' '/'         // 左结合，比+/-优先级高
%left ISVOID          // 左结合
%left '~'             // 左结合（取反）
%left '@'             // 左结合（静态分发）
%left '.'             // 左结合（方法调用）
```

#### 6.5.2 结合性说明

- **%left**：左结合，如 `a + b + c` 解析为 `(a + b) + c`
- **%right**：右结合，如 `a = b = c` 解析为 `a = (b = c)`
- **%nonassoc**：无结合，如 `a < b < c` 是语法错误

#### 6.5.3 优先级示例

在`cool.y`中的实际声明：
```bison
%nonassoc IN
%right ASSIGN
%right NOT
%nonassoc LE '<' '='
%left '+' '-'
%left '*' '/'
%left ISVOID
%left '~'
%left '@'
%left '.'
```

这意味着：
- `a + b * c` → `a + (b * c)`（`*`优先级高于`+`）
- `a = b = c` → `a = (b = c)`（`=`右结合）
- `a + b - c` → `(a + b) - c`（`+`和`-`左结合，同优先级）

### 6.6 错误恢复

#### 6.6.1 错误恢复机制

Bison提供了`error`关键字用于错误恢复。当遇到语法错误时，解析器会尝试跳过错误并继续解析。

```bison
class : CLASS TYPEID '{' feature_list '}' ';'
      | error ';'  // 如果遇到错误，跳过到分号
      {
          @$ = @1;
          $$ = class_(idtable.add_string("Error"), 
                      idtable.add_string("Object"), 
                      nil_Features(), 
                      stringtable.add_string(curr_filename));
      }
      ;
```

**说明**：
- `error`关键字表示"匹配任何错误"
- `error ';'`表示"跳过错误，直到遇到分号"
- 错误恢复动作应该创建一个合理的默认AST节点

#### 6.6.2 错误处理函数

`yyerror`函数在每次检测到语法错误时被调用：

```c++
void yyerror(char *s)
{
  extern char *curr_filename;
  
  cerr << "\"" << curr_filename << "\", line " << curr_lineno << ": " 
       << s << " at or near ";
  print_cool_token(yychar);  // 打印出错的token
  cerr << endl;
  omerrs++;  // 错误计数
  
  if(omerrs > 50) {
    fprintf(stdout, "More than 50 errors\n");
    exit(1);
  }
}
```

### 6.7 空产生式

#### 6.7.1 空产生式的作用

空产生式（epsilon产生式）用于表示"可选"或"可以为空"的语法结构。

```bison
formal_list : /* empty */
              { $$ = nil_Formals(); }
            | formal
              { $$ = single_Formals($1); }
            | formal_list ',' formal
              { $$ = append_Formals($1, single_Formals($3)); }
            ;
```

**解释**：
- `/* empty */`：空产生式，匹配空字符串
- 第一个产生式：空列表 → 返回空列表
- 第二个产生式：单个formal → 创建包含一个formal的列表
- 第三个产生式：列表 + formal → 追加formal到列表

#### 6.7.2 空产生式示例

```bison
feature_list : /* empty */
               { $$ = nil_Features(); }
             | feature_list feature ';'
               { $$ = append_Features($1, single_Features($2)); }
             ;
```

这允许类定义中没有任何特征（空类）：
```cool
class Empty {
};
```

## 七、实现步骤指导

### 7.1 开始实现前的准备

1. **理解Cool语言语法**：
   - 阅读Cool语言规范文档
   - 查看`good.cl`和`bad.cl`和`stack.cl`和`complex.cl`示例文件
   - 理解各种语法结构的含义

2. **理解AST结构**：
   ```bash
   # 查看官方parser的输出，了解AST格式
   ./lexer good.cl | /usr/class/bin/parser
   ```

3. **理解现有代码**：
   - 查看`cool.y`的初始结构（如果有）
   - 理解`cool-tree.h`中的AST节点定义
   - 理解各种构造函数的使用方法

### 7.2 实现步骤建议

#### 步骤1：设置基础结构

1. 确保`cool.y`文件包含所有必要的声明：
   - `%union`定义所有需要的类型
   - `%token`声明所有token
   - `%type`声明所有非终结符
   - 运算符优先级声明

2. 定义起始规则：
   ```bison
   program : class_list
             { @$ = @1; ast_root = program($1); }
             ;
   ```

#### 步骤2：实现类定义

1. 实现`class_list`规则（递归列表）
2. 实现`class`规则（单个类定义）
3. 实现`feature_list`规则（特征列表，可以为空）

#### 步骤3：实现特征定义

1. 实现`feature`规则（方法或属性）
2. 实现`formal_list`规则（形式参数列表）
3. 实现`formal`规则（单个形式参数）

#### 步骤4：实现表达式（从简单到复杂）

1. **基础表达式**：
   - 常量：`INT_CONST`、`BOOL_CONST`、`STR_CONST`
   - 变量：`OBJECTID`
   - 括号：`'(' expr ')'`

2. **一元运算符**：
   - `'~' expr`（取反）
   - `NOT expr`（逻辑非）
   - `ISVOID expr`（判空）
   - `NEW TYPEID`（新建对象）

3. **二元运算符**（按优先级从低到高）：
   - `expr ASSIGN expr`（赋值）
   - `expr '+' expr`、`expr '-' expr`（加减）
   - `expr '*' expr`、`expr '/' expr`（乘除）
   - `expr '<' expr`、`expr '=' expr`、`expr LE expr`（比较）

4. **复杂表达式**：
   - `IF expr THEN expr ELSE expr FI`（条件）
   - `WHILE expr LOOP expr POOL`（循环）
   - `CASE expr OF case_list ESAC`（分支）
   - `'{' expr_block_list '}'`（代码块）
   - `LET ... IN expr`（let表达式）
   - `expr '.' OBJECTID '(' expr_list ')'`（方法调用）
   - `expr '@' TYPEID '.' OBJECTID '(' expr_list ')'`（静态方法调用）

#### 步骤5：实现列表和块

1. `expr_list`：逗号分隔的表达式列表（用于方法调用参数）
2. `expr_block_list`：分号分隔的表达式列表（用于代码块）
3. `case_list`：case分支列表
4. `case_branch`：单个case分支

#### 步骤6：实现错误恢复

为关键规则添加错误恢复产生式，如：
```bison
class : CLASS TYPEID '{' feature_list '}' ';'
      | error ';' { /* 错误恢复 */ }
      ;
```

### 7.3 调试技巧

1. **逐步实现**：
   - 每实现一部分就编译测试
   - 先让简单语法工作，再添加复杂语法

2. **对比输出**：
   ```bash
   # 对比你的输出和官方输出
   ./lexer good.cl | ./parser > my_output.txt
   ./lexer good.cl | /usr/class/bin/parser > official_output.txt
   diff my_output.txt official_output.txt
   ```

3. **查看状态机**：
   ```bash
   # 查看Bison生成的状态机
   less cool.output
   ```

4. **使用简单测试文件**：
   - 创建最简单的测试文件，如只有一个空类
   - 逐步添加语法结构，测试每个部分

### 7.4 常见实现错误

1. **忘记设置行号**：
   ```bison
   // 错误：没有设置@$
  expr : INT_CONST { $$ = int_const($1); }
   
   // 正确：设置@\$和node_lineno
   expr : INT_CONST { @$ = @1; SET_NODELOC(@1); $$ = int_const($1); }
   ```

2. **列表构建错误**：
   ```bison
   // 错误：直接使用append，但第一个参数不是列表
   class_list : class { $$ = append_Classes($1, ...); }
   
   // 正确：先创建单元素列表
   class_list : class { $$ = single_Classes($1); }
   ```

3. **let表达式嵌套错误**：
   - 多个let绑定需要嵌套，如`let x:Int, y:Int in expr`应该解析为`let(x, Int, no_expr, let(y, Int, no_expr, expr))`

4. **运算符优先级错误**：
   - 确保优先级声明顺序正确（从低到高）
   - 确保结合性正确（左结合、右结合、无结合）

## 八、测试要求

### 8.1 good.cl测试

`good.cl`应该包含所有合法的Cool语法结构：
- 类定义（有/无继承）
- 方法定义
- 属性定义（有/无初始化）
- 所有类型的表达式
- 控制流语句（if, while, case）
- let表达式
- 类型转换和方法调用

### 8.2 bad.cl测试

`bad.cl`应该包含各种语法错误：
- 缺少关键字
- 缺少括号/大括号
- 错误的token顺序
- 缺少分号
- 等等

### 8.3 自定义测试

建议添加自己的测试文件，覆盖边界情况和复杂场景。

## 九、常见问题

### Q1: 编译时提示"undefined reference to XXX"
**A**: 检查是否在`cool.y`的`%%`之后定义了必要的全局变量，如：
- `int curr_lineno = 1;`
- `Symbol self_sym = idtable.add_string("self");`
- `Program ast_root;`

### Q2: 运行时提示"syntax error at or near TYPEID"
**A**: 
1. 检查token值是否与`cool-parse.h`一致
2. 检查语法规则是否正确匹配token序列
3. 使用官方parser对比输出

### Q3: make clean后lexer丢失
**A**: 这是正常的，`make clean`会删除符号链接。重新执行：
```bash
ln -s /usr/class/bin/lexer .
```

### Q4: 如何查看AST输出格式？
**A**: 运行官方parser查看输出格式：
```bash
./lexer good.cl | /usr/class/bin/parser
```

### Q5: 如何调试语法规则？
**A**: 
1. 查看`cool.output`文件了解状态机
2. 使用官方parser对比输出
3. 逐步添加语法规则，每添加一部分就测试

### Q6: 如何理解AST节点构造函数？
**A**: 
1. 查看`cool-tree.h`中的函数声明
2. 查看官方parser的输出，了解AST结构
3. 参考`cool.y`中的示例用法

### Q7: make parser时提示"bison: command not found"
**A**: 需要安装bison：
```bash
# Ubuntu/Debian
sudo apt-get install bison

# 检查bison版本
bison --version
```

### Q8: 如何理解token值？
**A**: 
1. token值在`cool.y`中显式指定（如`CLASS 258`）
2. 这些值必须与lexer输出的token值匹配
3. 可以通过`./lexer good.cl`查看lexer输出的token值
4. 可以通过`cool.tab.h`查看Bison生成的token定义

### Q9: 为什么需要设置`@$`和`SET_NODELOC`？
**A**: 
- `@$`设置当前规则的位置信息（行号）
- `SET_NODELOC`设置AST节点的行号，用于错误报告
- 如果不设置，AST节点可能没有正确的行号信息，导致错误报告不准确

### Q10: let表达式如何处理多个绑定？
**A**: 
多个let绑定需要嵌套处理。例如：
```cool
let x:Int <- 1, y:Int <- 2 in x + y
```
应该解析为：
```c++
let(x, Int, 1, let(y, Int, 2, plus(x, y)))
```
即：外层let绑定x，内层let绑定y，最内层是表达式。

## 十、评分标准

- 语法规则正确性：能否正确解析所有合法语法
- 错误处理：能否正确检测和报告语法错误
- 代码质量：代码清晰、注释充分
- 测试充分性：测试用例覆盖全面
- 报告质量：设计说明清晰、正确性证明充分

## 十一、参考资料

- Bison官方文档：https://www.gnu.org/software/bison/manual/

## 十二、提交要求

提交前请确保(参考4.5的内容)：
1. 代码能正确编译（`make parser`成功）
2. `good.cl`能正确解析
3. `bad.cl`的错误能被正确检测
4. `stack.cl`能正确解析
5. `complex.cl`能正确解析
6. 按照作业2的 latex格式提交作业即可

