% !TEX program = xelatex
\documentclass[twocolumn]{article}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{float}

% --- 页面布局 ---
\geometry{a4paper, left=2cm, right=2cm, top=2.5cm, bottom=2.5cm, columnsep=1cm}

% --- 代码高亮配置 ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    columns=flexible,
    literate={\_}{{\textunderscore}}1,
    mathescape=false,
    texcl=false
}
\lstset{style=mystyle}

% --- 自定义 listings 语言 ---
\lstdefinelanguage{flex}{
    keywords={%
        options, case-insensitive, noyywrap, yylineno,
        x, s,
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{//},
    morecomment=[s][\color{codegreen}]{/*}{*/},
    morecomment=[s][\color{codegreen}]{\%\{}{\%\}},
    morestring=[b][\color{codepurple}]",
    alsoletter={-,>},
    morekeywords=[2]{BEGIN, ECHO, REJECT, yylval, yytext, yyleng, yylex, curr_lineno},
    mathescape=false,
    texcl=false,
}

\lstdefinelanguage{cool}{
    keywords={%
        class, inherits, if, then, else, fi, while, loop, pool, let, in, case, of, esac, new, isvoid, not, true, false,
        Int, String, Bool, Object, SELF_TYPE, self
    },
    sensitive=false,
    morecomment=[l][\color{codegreen}]{--},
    morecomment=[s][\color{codegreen}]{(*}{*)},
    morestring=[b][\color{codepurple}]",
    morekeywords=[2]{},
}

% --- 页眉页脚 ---
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{COOL 词法分析器实验报告}
\fancyhead[R]{\thepage}
\fancyfoot[C]{\small \copyright\ 2025}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% --- 标题 ---
\title{
    \vspace{-1cm}
    \textbf{COOL 语言词法分析器开发报告} \\
    \large \texttt{Compiler Principle Assignment}
}
\author{
    姓名: \textcolor{red}{谭润} \\
    学号: \textcolor{red}{20238131027} \\
    班级: \textcolor{red}{大数据二班}
}
\date{\today}

% --- 文档开始 ---
\begin{document}

\maketitle
\thispagestyle{fancy}

\begin{abstract}
\noindent
本文档详细记录了 COOL (Classroom Object-Oriented Language) 词法分析器的设计与实现过程。报告深入阐述了Flex词法分析器的工作原理，包括有限状态自动机理论、模式匹配机制和状态转换过程；详细说明了词法规则的实现方法，涵盖关键字、标识符、字符串、注释及错误处理；最后通过完整的测试验证，包括集成测试，展示词法分析器与编译器其他组件的协作以及最终程序的正确运行。

\textbf{关键词：} 词法分析，Flex，有限状态自动机，COOL语言，编译器
\end{abstract}

\section{项目概述与环境}
\subsection{项目目标}
本次作业的目标是使用词法分析器生成工具 Flex 为 COOL 语言设计并实现一个完整的词法分析器。该分析器需要能够将 COOL 源代码文本文件转换为一个词法单元（Token）序列，并能正确处理各种边界情况和词法错误。

\subsection{开发环境}

\subsubsection{硬件配置}
\begin{itemize}
    \item \textbf{CPU}: \textcolor{red}{x86\_64架构，2核}
    \item \textbf{内存}: \textcolor{red}{总容量2.0Gi}
    \item \textbf{硬盘}: \textcolor{red}{根分区容量总计约 11G（文件系统为 ext4）}
\end{itemize}

\subsubsection{软件环境}
\begin{itemize}
    \item \textbf{操作系统}: \textcolor{red}{Ubuntu 22.04.1 LTS}
    \item \textbf{内核版本}: \textcolor{red}{5.15.0-60-generic}
    \item \textbf{Flex 版本}: \textcolor{red}{2.6.4-8build2}
    \item \textbf{G++ 版本}: \textcolor{red}{g++ (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0}
    \item \textbf{Make 版本}: \textcolor{red}{GNU Make 4.3}
    \item \textbf{SPIM 版本}: \textcolor{red}{SPIM Version 8.0 of January 8, 2010}
    \item \textbf{coolc 编译器版本}: \textcolor{red}{0.1}
    \item \textbf{vscode 编辑器版本}: \textcolor{red}{vscode 1.105.1(user setup)}
\end{itemize}

\subsubsection{项目目录结构}
\begin{verbatim}
/usr/class/assignments/PA2/
|-- cool.flex       
|-- test.cl           
|-- lexer             
|-- cool-lex.cc       
|-- Makefile           
|-- parser             
|-- semant            
`-- cgen              
\end{verbatim}

\subsubsection{环境配置过程}

安装依赖包：
\begin{verbatim}
sudo dpkg --add-architecture i386 
sudo apt update 
sudo apt install libc6:i386 
sudo apt install lib32z1 
sudo apt install zlib1g:i386 
sudo apt install libncurses5:i386
\end{verbatim}

安装工具：
\begin{verbatim}
sudo apt install flex
sudo apt install spim
\end{verbatim}

安装 coolc 编译器:
\begin{verbatim}
git clone https://github.com/aweinert/coolc.git
sudo apt install openjdk-11-jdk
sudo apt install maven
\end{verbatim}

环境变量配置：
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{env.png}
    \caption{环境变量配置内容}
    \label{fig:env_config}
\end{figure}

环境变量具体配置内容：
\begin{verbatim}
export PATH=/usr/class/bin:$PATH
export LD_LIBRARY_PATH=/usr/class/lib:$LD_LIBRARY_PATH  
export LDFLAGS="-L/usr/lib/x86_64-linux-gnu/"
\end{verbatim}

\section{Flex词法分析器原理}

\subsection{Flex工作流程}

Flex从.flex文件到可执行词法分析器的完整流程如图\ref{fig:flex_workflow}所示。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Flex_work.png}
    \caption{Flex词法分析器工作流程图}
    \label{fig:flex_workflow}
\end{figure}

\textbf{详细步骤说明：}
\begin{enumerate}
    \item \textbf{读取.flex文件}：Flex读取包含正则表达式规则和动作代码的源文件
    \item \textbf{规则解析}：Flex解析三个部分（定义段、规则段、用户代码段）
    \item \textbf{自动机生成}：
    \begin{itemize}
        \item 将正则表达式转换为NFA（非确定有限自动机）
        \item 通过子集构造法将NFA转换为DFA（确定有限自动机）
        \item 对DFA进行最小化优化
    \end{itemize}
    \item \textbf{代码生成}：生成cool-lex.cc文件，包含DFA表和匹配逻辑
    \item \textbf{编译链接}：使用g++编译生成可执行文件lexer
    \item \textbf{词法分析}：lexer读取COOL源代码，输出Token序列
\end{enumerate}

\subsection{有限状态自动机（FSA）原理}

\subsubsection{FSA基本概念}
有限状态自动机是由状态集合、输入字母表、状态转移函数、初始状态和接受状态组成的数学模型。

\subsubsection{NFA与DFA的区别}
\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|l|X|X|}
\hline
\textbf{特性} & \textbf{NFA（非确定有限自动机）} & \textbf{DFA（确定有限自动机）} \\
\hline
状态转移 & 一个状态对同一输入可以有多个转移 & 每个状态对每个输入只有唯一转移 \\
\hline
ε转移 & 允许空串转移 & 不允许空串转移 \\
\hline
效率 & 匹配时需要回溯，效率较低 & 无回溯，匹配效率高 \\
\hline
实现 & 易于从正则表达式构建 & 需要通过NFA转换得到 \\
\hline
\end{tabularx}
\caption{NFA与DFA特性对比}
\label{tab:nfa_dfa}
\end{table}

\subsubsection{Flex的自动机构建过程}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{Flex_auto_create.png}
    \caption{Flex的自动机构建过程}
    \label{fig:flex_auto_create}
\end{figure}

\subsubsection{示例：识别整数"[0-9]+"的自动机}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{example1.jpg}
    \caption{识别整数[0-9]+的自动机图示}
    \label{fig:example_nfa_dfa}
\end{figure}

\textbf{转换过程说明：}
\begin{enumerate}
    \item \textbf{NFA构建}：使用Thompson算法从正则表达式构建NFA
    \item \textbf{子集构造}：将NFA状态集合作为DFA的单个状态
    \item \textbf{DFA最小化}：合并等价状态，减少状态数量
\end{enumerate}

\textbf{为什么DFA效率更高：}
\begin{itemize}
    \item DFA在匹配时不需要回溯，每个输入字符只需一次状态转移
    \item NFA可能需要尝试多条路径，存在回溯开销
\end{itemize}

\subsection{模式匹配机制}

Flex使用以下机制进行模式匹配：

\subsubsection{最长匹配原则（Longest Match）}
Flex总是选择匹配最长输入串的规则。

\begin{lstlisting}[language=Flex, caption={最长匹配原则示例}, label=code:longest_match]
%%
"if"     { return IF; }      // 匹配"if"
"ifelse" { return IFELSE; }  // 匹配"ifelse"（更长）
[a-z]+   { return ID; }      // 匹配其他标识符
%%
\end{lstlisting}

\textbf{示例：}输入"ifelse"时，会匹配"ifelse"而不是先匹配"if"。

\subsubsection{规则优先级（First Match）}
当多个规则匹配相同长度时，先定义的规则优先。

\textbf{关键示例：关键字vs标识符}

\begin{lstlisting}[language=Flex, caption={正确的规则顺序}, label=code:correct_order]
// 正确顺序：关键字在前
"if"     { return IF; }      // 优先匹配
"while"  { return WHILE; }   // 优先匹配  
[a-z]+   { return ID; }      // 通用模式在后
\end{lstlisting}

\begin{lstlisting}[language=Flex, caption={错误的规则顺序}, label=code:wrong_order]
// 错误顺序：标识符在前
[a-z]+   { return ID; }      // 会匹配所有小写字母串，包括关键字
"if"     { return IF; }      // 永远不会执行！
\end{lstlisting}

\subsubsection{在代码中的体现}
\begin{lstlisting}[language=C++, caption={模式匹配实现}, label=code:pattern_impl]
[cC][lL][aA][sS][sS] { return CLASS; }
// ... 其他关键字
{DAXIEZIMU}{ZIMUSHIZI}* { 
    kulouyylval.symbol = strdup(yytext);
    return TYPEID;
}
{XIAOXIEZIMU}{ZIMUSHIZI}* { 
    kulouyylval.symbol = strdup(yytext);
    return OBJECTID;
}
\end{lstlisting}

\subsubsection{核心变量作用}
\begin{itemize}
    \item \textbf{\texttt{yytext}}：指向当前匹配的文本字符串
    \item \textbf{\texttt{yyleng}}：匹配文本的长度
    \item \textbf{\texttt{yylval}}：用于向语法分析器传递Token值（在代码中是\texttt{kulouyylval}）
\end{itemize}

\subsection{状态与状态转换}

Flex的状态机制允许词法分析器在不同的上下文中使用不同的匹配规则，这对于处理复杂的词法结构至关重要。

\subsubsection{Flex状态类型}
\begin{itemize}
    \item \textbf{INITIAL}：默认初始状态
    \item \textbf{独占状态（\%x）}：只有明确标记为该状态的规则才会被匹配
    \item \textbf{包容状态（\%s）}：该状态的规则 + 无状态标记的规则都会匹配
\end{itemize}

\subsubsection{状态声明}
\begin{lstlisting}[language=Flex, caption={状态声明}, label=code:state_decl]
%x ZIFUCHUAN    // 独占状态：处理字符串
%x ZHUSHI       // 独占状态：处理注释
\end{lstlisting}

\subsubsection{状态转换机制}
\texttt{BEGIN(state)}宏用于切换状态，改变Flex的匹配规则集合。

\subsubsection{字符串处理状态转换图}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{status_change.png}
    \caption{字符串处理状态转换图}
    \label{fig:status_change}
\end{figure}

\subsubsection{状态转换具体过程（以STRING状态为例）}

\textbf{从INITIAL进入STRING：}
\begin{lstlisting}[language=Flex, caption={进入STRING状态}, label=code:enter_string]
"\"" { 
    BEGIN(ZIFUCHUAN); 
    zifuchuanhuanchongquzhizhen = zifuchuanhuanchongqu; 
}
\end{lstlisting}

\textbf{在STRING状态中处理不同字符：}
\begin{lstlisting}[language=Flex, caption={STRING状态字符处理}, label=code:string_processing]
<ZIFUCHUAN>"\"" { 
    *zifuchuanhuanchongquzhizhen = '\0';
    kulouyylval.symbol = strdup(zifuchuanhuanchongqu);
    BEGIN(INITIAL);
    return STR_CONST;
}
<ZIFUCHUAN>\\n { *zifuchuanhuanchongquzhizhen++ = '\n'; }  // 转义处理
<ZIFUCHUAN>\n { 
    dangqianhanghao++; 
    kulouyylval.error_msg = "Unterminated string constant";
    BEGIN(INITIAL);
    return ERROR;
}
\end{lstlisting}

\textbf{返回INITIAL状态：}
\begin{itemize}
    \item 遇到结束引号：\texttt{BEGIN(INITIAL)}并返回\texttt{STR\_CONST}
    \item 遇到错误情况（换行、EOF）：\texttt{BEGIN(INITIAL)}并返回\texttt{ERROR}
\end{itemize}

\subsubsection{为什么需要状态机制}
\begin{itemize}
    \item \textbf{上下文相关处理}：字符串内的空格和注释内的关键字不应被正常解析
    \item \textbf{嵌套结构}：注释可以嵌套\texttt{(* outer (* inner *) outer *)}
    \item \textbf{复杂词法结构}：字符串转义、多行注释等需要特殊处理
\end{itemize}

% 后续章节保持不变...
\section{实现细节}
本节简要说明词法规则的实现思路。完整代码见附录。

\subsection{关键字与标识符}

\textbf{基本要求：}
\begin{itemize}
    \item 关键字（如class、if、while等）是大小写不敏感的
    \item 布尔常量true和false的首字母必须小写
    \item TYPE\_ID以大写字母开头，OBJECT\_ID以小写字母开头
    \item 整数常量为数字序列
\end{itemize}

\textcolor{red}{%
% TODO: 说明你如何实现关键字的大小写不敏感、如何区分两种标识符。
% 特别说明：如何处理关键字与标识符的优先级问题。
}

\subsection{字符串处理}

\textbf{基本要求：}
\begin{itemize}
    \item 字符串以双引号开始和结束，不能跨行
    \item 支持转义字符：\texttt{\textbackslash n}, \texttt{\textbackslash t}, \texttt{\textbackslash b}, \texttt{\textbackslash f}, \texttt{\textbackslash"}, \texttt{\textbackslash\textbackslash}
    \item 最大长度1024字符，不能包含空字符
    \item 需要使用Flex状态机（\texttt{\%x STRING}）处理
\end{itemize}

\textcolor{red}{%
% TODO: 详细说明你的字符串状态机设计：
% 1. 如何进入和退出STRING状态
% 2. 如何处理各种转义字符
% 3. 如何检测和报告错误（未闭合、过长、包含空字符、EOF等）
% 4. 如何使用字符串缓冲区
}

% 其他章节保持不变...

\appendix
\section{附录: cool.flex 完整源码}
\label{sec:appendix_code}

\textcolor{red}{%
% TODO: 将你完成的cool.flex文件放在与此tex文件相同的目录下。
% 重新编译后，完整代码会自动包含在这里。
}

\IfFileExists{cool.flex}
  {\lstinputlisting[language=flex, basicstyle=\ttfamily\tiny]{cool.flex}}
  {
\textbf{说明：}将完成的 \texttt{cool.flex} 文件放在同一目录下，重新编译即可自动包含完整代码。

示例结构（3段式）：定义段 -- 规则段 -- 用户代码段
}

\end{document}